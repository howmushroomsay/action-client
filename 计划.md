k_{11} & k_{12} & k_{13} \\ k_{21} & k_{22} & k_{23} \\ k_{31} & k_{32} & k_{33} \end{bmatrix} \] 同时，输入图像在某位置处的一个3x3区域记作 \( I \)： \[ I = \begin{bmatrix} i_{11} & i_{12} & i_{13} \\ i_{21} & i_{22} & i_{23} \\ i_{31} & i_{32} & i_{33} \end{bmatrix} \] 那么，卷积操作可以简化表示为这两个矩阵之间的元素级乘加运算，得到输出的一个值 \( O \)： \[ O = (k_{11} \times i_{11}) + (k_{12} \times i_{12}) + (k_{13} \times i_{13}) + (k_{21} \times i_{21}) + (k_{22} \times i_{22}) + (k_{23} \times i_{23}) + (k_{31} \times i_{31}) + (k_{32} \times i_{32}) + (k_{33} \times i_{33}) \] 实际上，这个操作包含了步长为1、没有填充的3x3卷积核对输入图像的一次局部扫描。在实际的卷积神经网络中，卷积核会遍历整个输入图像的所有合适位置，并产生一个新的特征图作为输出。每个输出像素都是对应输入区域与卷积核做类似上述计算的结果。若涉及到步长(stride)不为1、有填充(padding)的情况，还需额外的调整计算范围和位置。 为了直观理解，以下是带步长和填充的3x3卷积在二维空间上的示意图： ``` 输入图像(I) -- [卷积操作(核K)] --> 输出特征图(O) ``` 其中，卷积核会在输入图像上滑动并逐点计算新的特征值。